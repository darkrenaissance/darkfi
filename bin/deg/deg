#!/usr/bin/python3

# This file is part of DarkFi (https://dark.fi)
#
# Copyright (C) 2020-2024 Dyne.org foundation
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import asyncio, random, re, sys, base58, json
import base58
import urwid as u
import networkx as nx
from datetime import datetime
# import matplotlib.pyplot as plt
import src.util

from os.path import join

resolved = True

class JsonRpc:

    async def start(self, server, port):
        reader, writer = await asyncio.open_connection(server, port, limit=1024 * 128)
        self.reader = reader
        self.writer = writer

    async def stop(self):
        self.writer.close()
        await self.writer.wait_closed()

    async def _make_request(self, method, params):
        ident = random.randint(0, 2**16)
        #print(ident)
        request = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params,
            "id": ident,
        }

        message = json.dumps(request) + "\n"
        self.writer.write(message.encode())
        await self.writer.drain()

        data = await self.reader.readline()
        message = data.decode().strip()
        response = json.loads(message)
        #print(response)
        return response

    async def _subscribe(self, method, params):
        ident = random.randint(0, 2**16)
        request = {
            "jsonrpc": "2.0",
            "method": method,
            "params": params,
            "id": ident,
        }

        message = json.dumps(request) + "\n"
        self.writer.write(message.encode())
        await self.writer.drain()
        #print("Subscribed")

    async def ping(self):
        return await self._make_request("ping", [])

    async def dnet_switch(self, state):
        return await self._make_request("dnet.switch", [state])

    async def dnet_subscribe_events(self):
        return await self._subscribe("dnet.subscribe_events", [])
    
    async def deg_switch(self, state):
        return await self._make_request("deg.switch", [state])


def check_multi_ev_in_layer(dag_dict, dag):
    gen = list(nx.topological_generations(dag))
    for i in gen:
        # fork
        if len(i) == 2:
            event1 = dag_dict[i[0]]
            event2 = dag_dict[i[1]]
            if int(event1['timestamp']) > int(event2['timestamp']):
                return i[0]
            else:
                return i[1]



def graph(event, dag, x):
    global resolved
    merge = len(list(dag.predecessors(event['hash']))) > 1
    fork = len(list(dag.successors(event['hash']))) > 1
    
    if merge and not fork:
        resolved = False
        return "     M━┑"
    if fork and not merge:
        resolved = True
        return "     o─┘"
    if merge and fork:
        return "     M━┪"
    if not merge and not fork:
        if event['hash'] == x:
            return "     │ o"
        else:
            if not resolved:
                return "     o │"
            else:
                return "     o  "
            #  "     │ o"
            #  "     o │"
            #  "     o━┪"
            #  "     o─┴"
            #  "     o━┯"


class ListItem(u.WidgetWrap):
    
    def __init__ (self, event, dag, x):
        g = graph(event, dag, x)
        self.content = event
        layer_num = int(event["layer"])
        layer = "layer " + str(layer_num) if layer_num != 0 else "genesis"
        dt = datetime.fromtimestamp(int(event['timestamp']))
        t = u.AttrMap(u.Text([('word', str(dt)),
                              ('committer', " " + layer),
                              ('word', g),
                              ('cont', event['content'])], wrap="ellipsis"),
                              {'word':'datetime', 'committer': 'reporter', 'cont': 'content'},
                              {'word':'event_selected', 'committer': 'event_selected', 'cont': 'event_selected'})
        u.WidgetWrap.__init__(self, t)

    def selectable (self):
        return True
    
    def keypress(self, size, key):
        return key

class ListView(u.WidgetWrap):

    def __init__(self):
        u.register_signal(self.__class__, ['show_details'])
        self.walker = u.SimpleFocusListWalker([])
        lb = u.ListBox(self.walker)
        u.WidgetWrap.__init__(self, lb)

    def modified(self):
        focus_w, _ = self.walker.get_focus()
        u.emit_signal(self, 'show_details', focus_w.content)

    def set_data(self, events, dag, x):
        events_widgets = [ListItem(e, dag, x) for e in events]
        u.disconnect_signal(self.walker, 'modified', self.modified)

        while len(self.walker) > 0:
            self.walker.pop()
        
        self.walker.extend(events_widgets)
        u.connect_signal(self.walker, "modified", self.modified)
        self.walker.set_focus(0)

class DetailView(u.WidgetWrap):
    
    def __init__ (self):
        t = u.Text("")
        u.WidgetWrap.__init__(self, t)
        
    def set_event(self, c):
        s = f'Hash: {c["hash"]}\nChildren: {c["children"]}\nContent: {c["content"]}\nLayer: {c["layer"]}'
        self._w.set_text(s)

class App(object):
    
    def unhandled_input(self, key):
        if key in ('q',):
            raise u.ExitMainLoop()
        # if key == 'r':
        #     await self.update_data(self.config)
        if key == 'enter':
            self.current_view = self.frame2
            self.loop.widget = self.frame2
        if key == 'b':
            self.current_view = self.frame1
            self.loop.widget = self.frame1

    def show_details(self, event):
        self.view_two.set_event(event)
        
    def __init__(self):
        self.view_one = ListView()
        u.connect_signal(self.view_one, 'show_details', self.show_details)
        footer = u.AttrWrap(u.Text(" Q to exit"), "footer")
        col_rows = u.raw_display.Screen().get_cols_rows()
        h = col_rows[0] - 2
        f1 = u.Filler(self.view_one, valign='top', height=h)
        c_list = u.LineBox(f1, title="Layers")
        columns = u.Columns([('weight', 100, c_list)])
        frame1 = u.AttrMap(u.Frame(body=columns, footer=footer), 'bg')
        self.frame1 = frame1
        ############
        # content = self.content
        # print(content)
        self.view_two = DetailView()
        # self.detail_view = DetailView()
        f2 = u.Filler(self.view_two, valign='top')
        c_details = u.LineBox(f2, title="Details")
        columns = u.Columns([('weight', 100, c_details)])
        frame2 = u.AttrMap(u.Frame(body=columns), 'bg')
        self.frame2 = frame2
        ##########
        self.current_view = self.frame1  # Start with View One
        self.palette = {
            ("bg",               "white",           "black"),
            ("event",            "white",           "black"),
            ("event_selected",   "white",           "light green"),
            ('datetime',         "light blue",      "black"),
            ('reporter',         "dark green",      "black"),
            ('content',          "",                "black"),
            ("footer",           "white, bold",     "dark red")
        }

    def build_main(self):
        return self.current_view
    
    async def update_data(self, config):
            self.config = config
            dag_dict = await recreate_dag(config)
            dag_list = list(dag_dict.items())
            # sorted_dag = sorted(dag_list, key=lambda x:x[1]['layer'])

            # genesis_hash = sorted_dag[0][0]

            parent_child_pairs = []
            for item in dag_list:
                parents = item[1]['parents']
                child = item[0]
                for parent in parents:
                    if parent == '0' * 64:
                        continue
                    parent_child_pairs.append((parent, child))
                    
            # Create a directed graph
            dag = nx.DiGraph()

            # Add edges to the graph (this also adds nodes)
            dag.add_edges_from(parent_child_pairs)
            l = []
            topological_order = list(nx.topological_sort(dag))
            for node in reversed(topological_order):
                event_details = dag_dict.get(node) # details
                layer = int(event_details['layer'])
                content = event_details['content'] # event content
                timestamp = event_details['timestamp']
                pattern = r'\\x[0-9A-Fa-f]{2}'
                decoded_str = str(base58.b58decode(content))
                matches = re.sub(pattern, ' ', decoded_str).replace("b'", "")[:-1]
                children = list(dag.successors(node))
                l.append({"layer":f"{layer}", "hash":f"{node}", "children":children, "content":f"{matches}", "timestamp": f"{timestamp}"})

            x = check_multi_ev_in_layer(dag_dict, dag)
            self.view_one.set_data(l, dag, x)

    async def start(self, config):
        # main_frame = self.build_main()
        await self.update_data(config)
        self.loop = u.MainLoop(self.current_view, self.palette, unhandled_input=self.unhandled_input)
        self.loop.run()

async def recreate_dag(config):
    host = config['host']
    port = config['port']
    rpc = JsonRpc()
    while True:
        try:
            await rpc.start(host, port)
            break
        except OSError:
            pass

    await rpc.deg_switch(True)
    await rpc.deg_switch(False)

    json_result = await rpc._make_request("eventgraph.get_info", [])
    
    if json_result['result']['eventgraph_info']:
        return json_result['result']['eventgraph_info']['dag']
        

async def main(argv):

    os = src.util.get_os()
    config_path = src.util.user_config_dir('darkfi', os)

    suffix = '.toml'
    filename = 'deg_config'
    path = join(config_path, filename + suffix)
    config = src.util.spawn_config(path)
    config = config['nodes'][0]

    if len(argv) > 1:
        if argv[1] in ['darkirc', 'irc']:
            config['port'] = 26660
        elif argv[1] in ['taud', 'tau']:
            config['port'] = 23330

    app = App()
    await app.start(config)
    

asyncio.run(main(sys.argv))
